package at.jodlidev.esmira.sharedCode.merlinInterpreter

import at.jodlidev.esmira.sharedCode.DbLogic
import at.jodlidev.esmira.sharedCode.NativeLink
import at.jodlidev.esmira.sharedCode.data_structure.DataSet
import at.jodlidev.esmira.sharedCode.data_structure.ErrorBox
import at.jodlidev.esmira.sharedCode.data_structure.Input
import at.jodlidev.esmira.sharedCode.data_structure.Message
import at.jodlidev.esmira.sharedCode.data_structure.Questionnaire
import kotlinx.serialization.encodeToString
import kotlinx.serialization.json.Json
import kotlin.math.max
import kotlin.math.min
import kotlin.math.pow
import kotlin.math.sqrt

/*
 * Created by SelinaDev
 *
 * The Interpreter is responsible for executing the translated code.
 * It is implemented as a Tree-Walk Interpreter, closely modelled after the jlox interpreter by Robert Nystrom: https://craftinginterpreters.com/
 * It can directly interpret the AST generated by the Parser.
 * Note that some of the logic for operating on different variable types is directly implemented in the respective classes inheriting MerlinType.
 */

class MerlinInterpreter: MerlinExpr.Visitor<MerlinType>, MerlinStmt.Visitor<Unit> {
    var globals = MerlinEnvironment()
    private var environment = globals
    private var isInitializing = false
    private var questionnaire: Questionnaire? = null

    fun getQuestionnaire(): Questionnaire? {
        return questionnaire
    }
    fun initialize(questionnaire: Questionnaire?, globalsObject: MerlinObject) {
        this.questionnaire = questionnaire
        isInitializing = false
        globals = MerlinEnvironment()
        for(func in nativeFunctions) {
            globals.defineFunction(func.key, func.value)
        }
        globals.define("globals", globalsObject)
        environment = globals
    }

    fun getGlobalsObject(): MerlinObject? {
        return globals.get("globals").let { if (it is MerlinObject) it else null }
    }

    fun cleanup() {
        questionnaire = null
    }

    fun interpret(statements: List<MerlinStmt>): MerlinType {
        try {
            for (statement in statements) {
                execute(statement)
            }
        } catch (e: MerlinReturn) {
            return e.value
        }
        return environment.currentReturnValue
    }

    private fun execute(stmt: MerlinStmt) {
        stmt.accept(this)
    }

    private fun evaluate(expr: MerlinExpr): MerlinType {
        return expr.accept(this)
    }

    fun executeBlock(statements: List<MerlinStmt>, environment: MerlinEnvironment) {
        val previous = this.environment
        try {
            this.environment = environment
            for (statement in statements) {
                execute(statement)
            }
        } finally {
            this.environment = previous
        }
    }

    override fun visitMerlinArrayExpr(expr: MerlinExpr.MerlinArrayExpr): MerlinType {
        return MerlinArray(expr.elements.map { evaluate(it) }.toMutableList())
    }

    override fun visitArrayGetExpr(expr: MerlinExpr.ArrayGet): MerlinType {
        val array = evaluate(expr.arr)
        if (array !is MerlinArray) throw MerlinRuntimeError(expr.bracket, "Access syntax ('[]') can only be used for arrays.")
        val index = evaluate(expr.index)
        index.asNumber()?.let {
            val integerIndex = MerlinArray.toIndex(it)
            if (!array.isIndexInRange(integerIndex)) throw MerlinRuntimeError(expr.bracket, "Array index out of range.")
            return array.array[integerIndex]
        }
        if (index is MerlinArray) {
            for(subIndex in index.array) {
                subIndex.asNumber()?.let {
                    val integerIndex = MerlinArray.toIndex(it)
                    if(!array.isIndexInRange(integerIndex)) throw MerlinRuntimeError(expr.bracket, "Array index out of range.")
                } ?: throw MerlinRuntimeError(expr.bracket, "Array-based access requires array of numbers.")
            }
            return MerlinArray(index.array.map { array.array[MerlinArray.toIndex(it.asNumber()!!)] }.toMutableList())
        }
        throw MerlinRuntimeError(expr.bracket, "Invalid array index.")
    }

    override fun visitBinaryExpr(expr: MerlinExpr.Binary): MerlinType {
        val left = evaluate(expr.left)
        val right = evaluate(expr.right)

        return when(expr.operator.type) {
            MerlinTokenType.PLUS,
                MerlinTokenType.MINUS,
                MerlinTokenType.STAR,
                MerlinTokenType.SLASH,
                MerlinTokenType.DOT_DOT,
                MerlinTokenType.GREATER,
                MerlinTokenType.GREATER_EQUAL,
                MerlinTokenType.LESS,
                MerlinTokenType.LESS_EQUAL,
                MerlinTokenType.EQUAL_EQUAL,
                MerlinTokenType.EXCLAMATION_EQUAL -> left.binary(right, expr.operator)
            else -> throw MerlinRuntimeError(expr.operator, "Invalid operator for binary operation.")
        }.getOrThrow()
    }

    override fun visitCallExpr(expr: MerlinExpr.Call): MerlinType {
        val callee = environment.getFunction(expr.callee) ?: throw MerlinRuntimeError(expr.callee, "Could not find called function.")

        val arguments = expr.arguments.map { evaluate(it) }
        if (arguments.size != callee.arity()) throw MerlinRuntimeError(expr.paren, "Wrong number of arguments for function call.")

        return callee.call(this, arguments)
    }

    override fun visitObjectGetExpr(expr: MerlinExpr.ObjectGet): MerlinType {
        val obj = evaluate(expr.obj)
        if (obj is MerlinObject) return obj.get(expr.name)
        throw MerlinRuntimeError(expr.name, "Only objects have properties.")
    }

    override fun visitGroupingExpr(expr: MerlinExpr.Grouping): MerlinType {
        return evaluate(expr.expression)
    }

    override fun visitLiteralExpr(expr: MerlinExpr.Literal): MerlinType {
        return expr.value
    }

    override fun visitLogicalExpr(expr: MerlinExpr.Logical): MerlinType {
        val left = evaluate(expr.left)

        if (left is MerlinArray) {
            val right = evaluate(expr.right)
            return left.binary(right, expr.operator).getOrThrow()
        } else if (expr.operator.type == MerlinTokenType.OR) {
            if (left.isTruthy()) return left
        } else {
            if (!left.isTruthy()) return left
        }

        return evaluate(expr.right)
    }

    override fun visitMerlinObjectExpr(expr: MerlinExpr.MerlinObject): MerlinType {
        return MerlinObject()
    }

    override fun visitSequenceExpr(expr: MerlinExpr.MerlinSequence): MerlinType {
        val start = evaluate(expr.start).asNumber()?.value ?: throw MerlinRuntimeError(expr.colon, "Sequence start requires a number.")
        val end = evaluate(expr.end).asNumber()?.value ?: throw MerlinRuntimeError(expr.colon, "Sequence end requires a number.")
        var step = 1.0
        expr.step?.let { step = evaluate(expr.step).asNumber()?.value ?: throw MerlinRuntimeError(expr.colon, "Sequence step requires a number.") }
        if (step <= 0) throw MerlinRuntimeError(expr.colon, "Sequence step must be positive.")
        var countingDown = false
        if (end < start) {
            step *= -1
            countingDown = true
        }
        val sequenceArray = mutableListOf<MerlinType>()
        var currentNum: Double
        var counted = 0
        do {
            currentNum = start + step * counted
            counted += 1
        } while (if (countingDown) currentNum > end else currentNum < end)
        return MerlinArray(sequenceArray)
    }

    override fun visitUnaryExpr(expr: MerlinExpr.Unary): MerlinType {
        val right = evaluate(expr.right)
        return right.unary(expr.operator).getOrThrow()
    }

    override fun visitVariableExpr(expr: MerlinExpr.Variable): MerlinType {
        return environment.get(expr.name)
    }

    override fun visitAssignStmt(stmt: MerlinStmt.Assign) {
        val value = evaluate(stmt.value)
        environment.assign(stmt.name, value, isInitializing)
    }

    override fun visitArraySetStmt(stmt: MerlinStmt.ArraySet) {
        val array = evaluate(stmt.arr)
        if (array !is MerlinArray) throw MerlinRuntimeError(stmt.bracket, "Access syntax ('[]') can only be used for arrays.")
        val index = evaluate(stmt.index)
        val value = evaluate(stmt.value)
        if(!isInitializing) {
            index.asNumber()?.let {
                val integerIndex = MerlinArray.toIndex(it)
                if (!array.isIndexInRange(integerIndex)) throw MerlinRuntimeError(stmt.bracket, "Array index out of range.")
                array.array[integerIndex] = value
                return
            }
            if (index is MerlinArray) {
                for(subIndex in index.array) {
                    subIndex.asNumber()?.let {
                        val integerIndex = MerlinArray.toIndex(it)
                        if(!array.isIndexInRange(integerIndex)) throw MerlinRuntimeError(stmt.bracket, "Array index out of range.")
                    } ?: throw MerlinRuntimeError(stmt.bracket, "Array-based access requires array of numbers.")
                }
                for(integerIndex in index.array.map { MerlinArray.toIndex(it.asNumber()!!) }) {
                    array.array[integerIndex] = value
                }
                return
            }
            throw MerlinRuntimeError(stmt.bracket, "Invalid array index.")
        }
    }

    override fun visitBlockStmt(stmt: MerlinStmt.Block) {
        executeBlock(stmt.statements, MerlinEnvironment(environment))
    }

    override fun visitExpressionStmt(stmt: MerlinStmt.Expression) {
        environment.currentReturnValue = evaluate(stmt.expression)
    }

    override fun visitForStmt(stmt: MerlinStmt.For) {
        val range = evaluate(stmt.iterable)
        if (range !is MerlinArray) throw MerlinRuntimeError(stmt.varName, "For loop requires an array to iterate.")
        val previous = this.environment
        try {
            for(element in range.array) {
                environment = MerlinEnvironment(previous)
                environment.define(stmt.varName.lexeme, element)
                execute(stmt.body)
            }
        } finally {
            this.environment = previous
        }
    }

    override fun visitFunctionStmt(stmt: MerlinStmt.Function) {
        val function = MerlinScriptFunction(stmt)
        environment.defineFunction(stmt.name.lexeme, function)
    }

    override fun visitIfStmt(stmt: MerlinStmt.If) {
        for(branch in stmt.branches) {
            if (evaluate(branch.first).isTruthy()) {
                execute(branch.second)
                return
            }
        }
        stmt.elseBranch?.let { execute(it) }
    }

    override fun visitInitStmt(stmt: MerlinStmt.Init) {
        isInitializing = true
        try {
            for (statement in stmt.statements)
                execute(statement)
        } finally { isInitializing = false }
    }

    override fun visitReturnStmt(stmt: MerlinStmt.Return) {
        val returnValue = stmt.value?.let { evaluate(it) } ?: environment.currentReturnValue
        throw MerlinReturn(returnValue)
    }

    override fun visitObjectSetStmt(expr: MerlinStmt.ObjectSet) {
        val obj = evaluate(expr.obj)

        if (obj !is MerlinObject) throw MerlinRuntimeError(expr.name, "Only objects have fields.")

        val value = evaluate(expr.value)
        if (isInitializing && obj.has(expr.name.lexeme)) return
        obj.set(expr.name, value)
    }

    override fun visitWhileStmt(stmt: MerlinStmt.While) {
        while (evaluate(stmt.condition).isTruthy()) {
            execute(stmt.body)
        }
    }

    companion object {
        val nativeFunctions: Map<String, MerlinFunction> = mapOf(
            //
            // Accessing questionnaire variables
            //

            // getQuestionnaireVar(varName)
            "getQuestionnaireVar" to object: MerlinFunction {
                override fun arity(): Int {
                    return 1
                }

                override fun call(
                    interpreter: MerlinInterpreter,
                    arguments: List<MerlinType>
                ): MerlinType {
                    val questionnaire = interpreter.getQuestionnaire() ?: return MerlinNone
                    val getSingleValue = { inputName: String ->
                        var out: MerlinType = MerlinNone
                        for (page in questionnaire.pages) {
                            for (input in page.inputs) {
                                if (input.name == inputName) {
                                    val value = input.getValue()
                                    out = if (value.isNotEmpty()) MerlinString(value) else MerlinNone
                                    break
                                }
                            }
                        }
                        out
                    }
                    val arg = arguments[0]
                    return if (arg is MerlinArray) {
                        MerlinArray(arg.array.map { getSingleValue(it.stringify()) }.toMutableList())
                    } else {
                        getSingleValue(arg.stringify())
                    }
                }
            },

            // getQuestionnaireVarAlternative(varName, alternativeKey)
            "getQuestionnaireVarAlternative" to object: MerlinFunction {
                override fun arity(): Int {
                    return 2
                }

                override fun call(
                    interpreter: MerlinInterpreter,
                    arguments: List<MerlinType>
                ): MerlinType {
                    val questionnaire = interpreter.getQuestionnaire() ?: return MerlinNone
                    val inputName = arguments[0].stringify()
                    var input: Input? = null
                    for(i in questionnaire.pages.map { it.inputs}.flatten())
                        if(i.name == inputName) {
                            input = i
                            break
                        }
                    input ?: return MerlinNone
                    val secondArg = arguments[1]
                    return if(secondArg is MerlinArray) {
                        MerlinArray(secondArg.array.map { input.getAdditional(it.stringify())?.let {MerlinString(it)} ?: MerlinNone }.toMutableList())
                    } else {
                        input.getAdditional(secondArg.stringify())?.let {MerlinString(it)} ?: MerlinNone
                    }
                }
            },

            // setVirtualItem(itemName, value)
            "setVirtualItem" to object: MerlinFunction {
                override fun arity(): Int {
                    return 2
                }

                override fun call(
                    interpreter: MerlinInterpreter,
                    arguments: List<MerlinType>
                ): MerlinType {
                    val questionnaire = interpreter.getQuestionnaire() ?: return MerlinType.createBool(false)
                    val inputName = arguments[0].stringify()
                    val value = arguments[1].stringify()
                    val virtualInput = questionnaire.virtualInputs[inputName] ?: return MerlinType.createBool(false)
                    virtualInput.setValue(value)
                    return MerlinType.createBool(true)
                }
            },

            // day()
            "day" to object: MerlinFunction {
                override fun arity(): Int {
                    return 0
                }

                override fun call(
                    interpreter: MerlinInterpreter,
                    arguments: List<MerlinType>
                ): MerlinType {
                    val now = NativeLink.getNowMillis()
                    val questionnaire = interpreter.questionnaire ?: return MerlinNone
                    val study = DbLogic.getStudy(questionnaire.studyId) ?: return MerlinNone
                    val joinedTimestamp = study.joinedTimestamp
                    val dateDiff = NativeLink.getDatesDiff(now, joinedTimestamp)
                    return if (dateDiff < 0)
                        MerlinNone
                    else
                        MerlinNumber(dateDiff.toDouble())
                }
            },

            //
            // Triggering Events in ESMira
            //

            // triggerQuestionnaire(questionnaireId, message, timeout)
            "triggerQuestionnaire" to object: MerlinFunction {
                override fun arity(): Int {
                    return 3
                }

                override fun call(
                    interpreter: MerlinInterpreter,
                    arguments: List<MerlinType>
                ): MerlinType {
                    val questionnaireId = arguments[0].asNumber()?.value?.toLong() ?: return MerlinType.createBool(false)
                    val studyId = interpreter.questionnaire?.studyId ?: return MerlinType.createBool(false)
                    val questionnaire = DbLogic.getQuestionnaireByInternalId(studyId, questionnaireId)?: return MerlinType.createBool(false)
                    val message = arguments[1].stringify()
                    val timeout = arguments[2].asNumber()?.value?.toInt() ?: 0

                    val now = NativeLink.getNowMillis()
                    questionnaire.updateLastNotification(now)
                    if (!questionnaire.canBeFilledOut(now)) {
                        ErrorBox.log(
                            "Notification",
                            "Questionnaire (${questionnaire.title}) is not active at ${NativeLink.formatDateTime(now)}. Skippin notification."
                        )
                        return MerlinType.createBool(false)
                    }
                    NativeLink.notifications.fireQuestionnaireBing(
                        questionnaire.title,
                        message,
                        questionnaire,
                        timeout,
                        DataSet.EventTypes.invitation,
                        now
                    )
                    return MerlinType.createBool(true)
                }
            },
            // triggerNotification(message)
            "triggerNotification" to object: MerlinFunction {
                override fun arity(): Int {
                    return 1
                }

                override fun call(
                    interpreter: MerlinInterpreter,
                    arguments: List<MerlinType>
                ): MerlinType {
                    val questionnaire = interpreter.questionnaire ?: return MerlinType.createBool(false)
                    val studyId = questionnaire.studyId
                    val study = DbLogic.getStudy(studyId)
                    val message = arguments[0].stringify()
                    val now = NativeLink.getNowMillis()

                    NativeLink.notifications.fireStudyNotification(
                        study?.title ?: "Notification",
                        message,
                        questionnaire,
                        now
                    )

                    return MerlinType.createBool(true)
                }
            },
            // triggerMessage(message)
            "triggerMessage" to object: MerlinFunction {
                override fun arity(): Int {
                    return 1
                }

                override fun call(
                    interpreter: MerlinInterpreter,
                    arguments: List<MerlinType>
                ): MerlinType {
                    val questionnaire = interpreter.questionnaire ?: return MerlinType.createBool(false)
                    val message = arguments[0].stringify()
                    val now = NativeLink.getNowMillis()
                    val study = DbLogic.getStudy(questionnaire.studyId) ?: return MerlinType.createBool(false)

                    Message.addMessage(study.id, message, now, true)
                    NativeLink.notifications.fireMessageNotification(study)
                    DataSet.createActionSentDataSet(DataSet.EventTypes.message, questionnaire, now)

                    return MerlinType.createBool(true)
                }
            },

            //
            // Mathematical Functions
            //

            // reverse(variables, min, max)
            "reverse" to object: MerlinFunction {
                override fun arity(): Int {
                    return 3
                }

                override fun call(
                    interpreter: MerlinInterpreter,
                    arguments: List<MerlinType>
                ): MerlinType {
                    val reverse = {num: MerlinType, offset: Double ->
                        num.asNumber()?.let { MerlinNumber(offset - it.value) } ?: num
                    }

                    val variables = arguments[0]
                    val min = arguments[1].asNumber()?.value ?: return variables
                    val max = arguments[2].asNumber()?.value ?: return variables
                    val offset = max + min
                    return if (variables is MerlinArray)
                        MerlinArray(variables.array.map { reverse(it, offset) }.toMutableList())
                    else
                        reverse(variables, offset)
                }
            },

            // sum(arr)
            "sum" to object: MerlinFunction {
                override fun arity(): Int {
                    return 1
                }

                override fun call(
                    interpreter: MerlinInterpreter,
                    arguments: List<MerlinType>
                ): MerlinType {
                    val arg = arguments[0]
                    if (arg !is MerlinArray)
                        return arg
                    return arg.array.map { it.asNumber()?.value ?: return MerlinNone }.reduceOrNull {acc, value -> acc + value}?.let {MerlinNumber(it)} ?: MerlinNone
                }
            },

            // mean(arr)
            "mean" to object: MerlinFunction {
                override fun arity(): Int {
                    return 1
                }

                override fun call(
                    interpreter: MerlinInterpreter,
                    arguments: List<MerlinType>
                ): MerlinType {
                    val arg = arguments[0]
                    if (arg !is MerlinArray)
                        return arg
                    return arg.array.map { it.asNumber()?.value ?: return MerlinNone }.reduceOrNull {acc, value -> acc + value}?.let {MerlinNumber(it/arg.array.size)} ?: MerlinNone
                }
            },

            // max(arr)
            "max" to object: MerlinFunction {
                override fun arity(): Int {
                    return 1
                }

                override fun call(
                    interpreter: MerlinInterpreter,
                    arguments: List<MerlinType>
                ): MerlinType {
                    val arg = arguments[0]
                    if (arg !is MerlinArray)
                        return arg
                    return arg.array.map { it.asNumber()?.value ?: return MerlinNone }.reduceOrNull {acc, value -> max(acc, value) }?.let { MerlinNumber(it) } ?: MerlinNone
                }
            },

            // min(arr)
            "min" to object: MerlinFunction {
                override fun arity(): Int {
                    return 1
                }

                override fun call(
                    interpreter: MerlinInterpreter,
                    arguments: List<MerlinType>
                ): MerlinType {
                    val arg = arguments[0]
                    if (arg !is MerlinArray)
                        return arg
                    return arg.array.map { it.asNumber()?.value ?: return MerlinNone }.reduceOrNull {acc, value -> min(acc, value) }?.let { MerlinNumber(it) } ?: MerlinNone
                }
            },

            // var(arr)
            "var" to object: MerlinFunction {
                override fun arity(): Int {
                    return 1
                }

                override fun call(
                    interpreter: MerlinInterpreter,
                    arguments: List<MerlinType>
                ): MerlinType {
                    val arg = arguments[0]
                    if (arg !is MerlinArray)
                        return arg
                    val numbersArr = arg.array.map { it.asNumber()?.value ?: return MerlinNone }
                    if (numbersArr.size < 2) return MerlinNone
                    val mean = numbersArr.reduceOrNull {acc, value -> acc + value}?.let { it / numbersArr.size } ?: return MerlinNone
                    val variance = numbersArr.map { (it - mean).pow(2) }.reduceOrNull { acc, value -> acc + value }?.let{ it / (numbersArr.size - 1) } ?: return MerlinNone
                    return MerlinNumber(variance)
                }
            },

            // sd(arr)
            "sd" to object: MerlinFunction {
                override fun arity(): Int {
                    return 1
                }

                override fun call(
                    interpreter: MerlinInterpreter,
                    arguments: List<MerlinType>
                ): MerlinType {
                    val arg = arguments[0]
                    if (arg !is MerlinArray)
                        return arg
                    val numbersArr = arg.array.map { it.asNumber()?.value ?: return MerlinNone }
                    if (numbersArr.size < 2) return MerlinNone
                    val mean = numbersArr.reduceOrNull {acc, value -> acc + value}?.let { it / numbersArr.size } ?: return MerlinNone
                    val variance = numbersArr.map { (it - mean).pow(2) }.reduceOrNull { acc, value -> acc + value }?.let{ it / (numbersArr.size - 1) } ?: return MerlinNone
                    return MerlinNumber(sqrt(variance))
                }
            },

            //
            // Array Functions
            //

            // any(arr)
            "any" to object: MerlinFunction {
                override fun arity(): Int {
                    return 1
                }

                override fun call(
                    interpreter: MerlinInterpreter,
                    arguments: List<MerlinType>
                ): MerlinType {
                    val arg = arguments[0]
                    if (arg !is MerlinArray)
                        return arg
                    return MerlinType.createBool(
                        arg.array.map { it.isTruthy() }.any { it }
                    )
                }
            }
        )
    }
}